/**
 *	Editor	: Jaeuk Kim
 *	Email	: phy000.kim@gmail.com
 *	Date	: March 2022 */

/** \file Computation.h 
 * \brief Source file for a Computation class and its derived classes.
 * It simplified the input and output for some calculations involving an ensemble of point configurations.
 * Computation PairStatisticsCLI code written by Ge.*/

#include "Computation.h"

/* Functions to write data in grace format. 
 *	Taken from Plots.cpp */
void PlotFunction_Grace(const std::vector<GeometryVector> * presult, size_t NumSet, const std::string & OutFilePrefix, const std::string & xLabel, const std::string & yLabel, const std::vector<std::string> & legends, const std::string & Title, double MinX, double MaxX, double TickX, double MinY, double MaxY, double TickY)
{
	const size_t NColor = 14;
	const size_t NLineStyle = 8;
	std::string name = OutFilePrefix + std::string(".agr");
	std::fstream ofile(name.c_str(), std::fstream::out);
	ofile.precision(15);
	ofile<<"# Grace project file\n";
	ofile<<"# Generated by PlotFunction_Grace. For more information, contact Ge Zhang.\n";
	ofile<<"@version 50122\n";
	ofile<<"@page size 792, 612\n";
	ofile<<"@page scroll 5%\n";
	ofile<<"@page inout 5%\n";
	ofile<<"@link page off\n";
	ofile<<"@map font 0 to \"Times-Roman\", \"Times-Roman\"\n";
	ofile<<"@map font 1 to \"Times-Italic\", \"Times-Italic\"\n";
	ofile<<"@map font 2 to \"Times-Bold\", \"Times-Bold\"\n";
	ofile<<"@map font 3 to \"Times-BoldItalic\", \"Times-BoldItalic\"\n";
	ofile<<"@map font 4 to \"Helvetica\", \"Helvetica\"\n";
	ofile<<"@map font 5 to \"Helvetica-Oblique\", \"Helvetica-Oblique\"\n";
	ofile<<"@map font 6 to \"Helvetica-Bold\", \"Helvetica-Bold\"\n";
	ofile<<"@map font 7 to \"Helvetica-BoldOblique\", \"Helvetica-BoldOblique\"\n";
	ofile<<"@map font 8 to \"Courier\", \"Courier\"\n";
	ofile<<"@map font 9 to \"Courier-Oblique\", \"Courier-Oblique\"\n";
	ofile<<"@map font 10 to \"Courier-Bold\", \"Courier-Bold\"\n";
	ofile<<"@map font 11 to \"Courier-BoldOblique\", \"Courier-BoldOblique\"\n";
	ofile<<"@map font 12 to \"Symbol\", \"Symbol\"\n";
	ofile<<"@map font 13 to \"ZapfDingbats\", \"ZapfDingbats\"\n";
	ofile<<"@map color 0 to (255, 255, 255), \"white\"\n";
	ofile<<"@map color 1 to (0, 0, 0), \"black\"\n";
	ofile<<"@map color 2 to (255, 0, 0), \"red\"\n";
	ofile<<"@map color 3 to (0, 255, 0), \"green\"\n";
	ofile<<"@map color 4 to (0, 0, 255), \"blue\"\n";
	ofile<<"@map color 5 to (188, 143, 143), \"brown\"\n";
	ofile<<"@map color 6 to (220, 220, 220), \"grey\"\n";
	ofile<<"@map color 7 to (148, 0, 211), \"violet\"\n";
	ofile<<"@map color 8 to (0, 255, 255), \"cyan\"\n";
	ofile<<"@map color 9 to (255, 0, 255), \"magenta\"\n";
	ofile<<"@map color 10 to (255, 165, 0), \"orange\"\n";
	ofile<<"@map color 11 to (114, 33, 188), \"indigo\"\n";
	ofile<<"@map color 12 to (103, 7, 72), \"maroon\"\n";
	ofile<<"@map color 13 to (64, 224, 208), \"turquoise\"\n";
	ofile<<"@map color 14 to (0, 139, 0), \"green4\"\n";
	ofile<<"@map color 15 to (255, 255, 0), \"yellow\"\n";
	ofile<<"@reference date 0\n";
	ofile<<"@date wrap off\n";
	ofile<<"@date wrap year 1950\n";
	ofile<<"@default linewidth 1.0\n";
	ofile<<"@default linestyle 1\n";
	ofile<<"@default color 1\n";
	ofile<<"@default pattern 1\n";
	ofile<<"@default font 0\n";
	ofile<<"@default char size 1.000000\n";
	ofile<<"@default symbol size 1.000000\n";
	ofile<<"@default sformat \"%.8g\"\n";
	ofile<<"@background color 0\n";
	ofile<<"@page background fill on\n";
	ofile<<"@timestamp off\n";
	ofile<<"@timestamp 0.03, 0.03\n";
	ofile<<"@timestamp color 1\n";
	ofile<<"@timestamp rot 0\n";
	ofile<<"@timestamp font 0\n";
	ofile<<"@timestamp char size 1.000000\n";
	ofile<<"@timestamp def \"";
	struct tm * now = localtime( & ::ProgramStart );
	ofile << (now->tm_year + 1900) << '-' 
		<< (now->tm_mon + 1) << '-'
		<<  now->tm_mday << ' '
		<< now->tm_hour <<':'
		<< now->tm_min <<':'
		<< now->tm_sec ;

	ofile<<"\"\n";
	ofile<<"@r0 off\n";
	ofile<<"@link r0 to g0\n";
	ofile<<"@r0 type above\n";
	ofile<<"@r0 linestyle 1\n";
	ofile<<"@r0 linewidth 1.0\n";
	ofile<<"@r0 color 1\n";
	ofile<<"@r0 line 0, 0, 0, 0\n";
	ofile<<"@r1 off\n";
	ofile<<"@link r1 to g0\n";
	ofile<<"@r1 type above\n";
	ofile<<"@r1 linestyle 1\n";
	ofile<<"@r1 linewidth 1.0\n";
	ofile<<"@r1 color 1\n";
	ofile<<"@r1 line 0, 0, 0, 0\n";
	ofile<<"@r2 off\n";
	ofile<<"@link r2 to g0\n";
	ofile<<"@r2 type above\n";
	ofile<<"@r2 linestyle 1\n";
	ofile<<"@r2 linewidth 1.0\n";
	ofile<<"@r2 color 1\n";
	ofile<<"@r2 line 0, 0, 0, 0\n";
	ofile<<"@r3 off\n";
	ofile<<"@link r3 to g0\n";
	ofile<<"@r3 type above\n";
	ofile<<"@r3 linestyle 1\n";
	ofile<<"@r3 linewidth 1.0\n";
	ofile<<"@r3 color 1\n";
	ofile<<"@r3 line 0, 0, 0, 0\n";
	ofile<<"@r4 off\n";
	ofile<<"@link r4 to g0\n";
	ofile<<"@r4 type above\n";
	ofile<<"@r4 linestyle 1\n";
	ofile<<"@r4 linewidth 1.0\n";
	ofile<<"@r4 color 1\n";
	ofile<<"@r4 line 0, 0, 0, 0\n";
	ofile<<"@g0 on\n";
	ofile<<"@g0 hidden false\n";
	ofile<<"@g0 type XY\n";
	ofile<<"@g0 stacked false\n";
	ofile<<"@g0 bar hgap 0.000000\n";
	ofile<<"@g0 fixedpoint off\n";
	ofile<<"@g0 fixedpoint type 0\n";
	ofile<<"@g0 fixedpoint xy 0.000000, 0.000000\n";
	ofile<<"@g0 fixedpoint format general general\n";
	ofile<<"@g0 fixedpoint prec 6, 6\n";
	ofile<<"@with g0\n";
	ofile<<"@    world "<<MinX<<", "<<MinY<<", "<<MaxX<<", "<<MaxY<<'\n';
	ofile<<"@    stack world 0, 0, 0, 0\n";
	ofile<<"@    znorm 1\n";
	ofile<<"@    view 0.250000, 0.200000, 1.150000, 0.850000\n";
	ofile<<"@    title \""<<Title<<"\"\n";
	ofile<<"@    title font 0\n";
	ofile<<"@    title size 1.500000\n";
	ofile<<"@    title color 1\n";
	ofile<<"@    subtitle \"\"\n";
	ofile<<"@    subtitle font 0\n";
	ofile<<"@    subtitle size 1.000000\n";
	ofile<<"@    subtitle color 1\n";
	ofile<<"@    xaxes scale Normal\n";
	ofile<<"@    yaxes scale Normal\n";
	ofile<<"@    xaxes invert off\n";
	ofile<<"@    yaxes invert off\n";
	ofile<<"@    xaxis  on\n";
	ofile<<"@    xaxis  type zero false\n";
	ofile<<"@    xaxis  offset 0.000000 , 0.000000\n";
	ofile<<"@    xaxis  bar on\n";
	ofile<<"@    xaxis  bar color 1\n";
	ofile<<"@    xaxis  bar linestyle 1\n";
	ofile<<"@    xaxis  bar linewidth 1.0\n";
	ofile<<"@    xaxis  label \""<<xLabel<<"\"\n";
	ofile<<"@    xaxis  label layout para\n";
	ofile<<"@    xaxis  label place auto\n";
	ofile<<"@    xaxis  label char size 3.000000\n";
	ofile<<"@    xaxis  label font 0\n";
	ofile<<"@    xaxis  label color 1\n";
	ofile<<"@    xaxis  label place normal\n";
	ofile<<"@    xaxis  tick on\n";
	ofile<<"@    xaxis  tick major "<<TickX<<"\n";
	ofile<<"@    xaxis  tick minor ticks 0\n";
	ofile<<"@    xaxis  tick default 6\n";
	ofile<<"@    xaxis  tick place rounded true\n";
	ofile<<"@    xaxis  tick in\n";
	ofile<<"@    xaxis  tick major size 1.000000\n";
	ofile<<"@    xaxis  tick major color 1\n";
	ofile<<"@    xaxis  tick major linewidth 1.0\n";
	ofile<<"@    xaxis  tick major linestyle 1\n";
	ofile<<"@    xaxis  tick major grid off\n";
	ofile<<"@    xaxis  tick minor color 1\n";
	ofile<<"@    xaxis  tick minor linewidth 1.0\n";
	ofile<<"@    xaxis  tick minor linestyle 1\n";
	ofile<<"@    xaxis  tick minor grid off\n";
	ofile<<"@    xaxis  tick minor size 0.500000\n";
	ofile<<"@    xaxis  ticklabel on\n";
	ofile<<"@    xaxis  ticklabel format general\n";
	ofile<<"@    xaxis  ticklabel prec 5\n";
	ofile<<"@    xaxis  ticklabel formula \"\"\n";
	ofile<<"@    xaxis  ticklabel append \"\"\n";
	ofile<<"@    xaxis  ticklabel prepend \"\"\n";
	ofile<<"@    xaxis  ticklabel angle 0\n";
	ofile<<"@    xaxis  ticklabel skip 0\n";
	ofile<<"@    xaxis  ticklabel stagger 0\n";
	ofile<<"@    xaxis  ticklabel place normal\n";
	ofile<<"@    xaxis  ticklabel offset auto\n";
	ofile<<"@    xaxis  ticklabel offset 0.000000 , 0.010000\n";
	ofile<<"@    xaxis  ticklabel start type auto\n";
	ofile<<"@    xaxis  ticklabel start 0.000000\n";
	ofile<<"@    xaxis  ticklabel stop type auto\n";
	ofile<<"@    xaxis  ticklabel stop 0.000000\n";
	ofile<<"@    xaxis  ticklabel char size 2.000000\n";
	ofile<<"@    xaxis  ticklabel font 0\n";
	ofile<<"@    xaxis  ticklabel color 1\n";
	ofile<<"@    xaxis  tick place both\n";
	ofile<<"@    xaxis  tick spec type none\n";
	ofile<<"@    yaxis  on\n";
	ofile<<"@    yaxis  type zero false\n";
	ofile<<"@    yaxis  offset 0.000000 , 0.000000\n";
	ofile<<"@    yaxis  bar on\n";
	ofile<<"@    yaxis  bar color 1\n";
	ofile<<"@    yaxis  bar linestyle 1\n";
	ofile<<"@    yaxis  bar linewidth 1.0\n";
	ofile<<"@    yaxis  label \""<<yLabel<<"\"\n";
	ofile<<"@    yaxis  label layout para\n";
	ofile<<"@    yaxis  label place auto\n";
	ofile<<"@    yaxis  label char size 3.000000\n";
	ofile<<"@    yaxis  label font 0\n";
	ofile<<"@    yaxis  label color 1\n";
	ofile<<"@    yaxis  label place normal\n";
	ofile<<"@    yaxis  tick on\n";
	ofile<<"@    yaxis  tick major "<<TickY<<"\n";
	ofile<<"@    yaxis  tick minor ticks 0\n";
	ofile<<"@    yaxis  tick default 6\n";
	ofile<<"@    yaxis  tick place rounded true\n";
	ofile<<"@    yaxis  tick in\n";
	ofile<<"@    yaxis  tick major size 1.000000\n";
	ofile<<"@    yaxis  tick major color 1\n";
	ofile<<"@    yaxis  tick major linewidth 1.0\n";
	ofile<<"@    yaxis  tick major linestyle 1\n";
	ofile<<"@    yaxis  tick major grid off\n";
	ofile<<"@    yaxis  tick minor color 1\n";
	ofile<<"@    yaxis  tick minor linewidth 1.0\n";
	ofile<<"@    yaxis  tick minor linestyle 1\n";
	ofile<<"@    yaxis  tick minor grid off\n";
	ofile<<"@    yaxis  tick minor size 0.500000\n";
	ofile<<"@    yaxis  ticklabel on\n";
	ofile<<"@    yaxis  ticklabel format general\n";
	ofile<<"@    yaxis  ticklabel prec 5\n";
	ofile<<"@    yaxis  ticklabel formula \"\"\n";
	ofile<<"@    yaxis  ticklabel append \"\"\n";
	ofile<<"@    yaxis  ticklabel prepend \"\"\n";
	ofile<<"@    yaxis  ticklabel angle 0\n";
	ofile<<"@    yaxis  ticklabel skip 0\n";
	ofile<<"@    yaxis  ticklabel stagger 0\n";
	ofile<<"@    yaxis  ticklabel place normal\n";
	ofile<<"@    yaxis  ticklabel offset auto\n";
	ofile<<"@    yaxis  ticklabel offset 0.000000 , 0.010000\n";
	ofile<<"@    yaxis  ticklabel start type auto\n";
	ofile<<"@    yaxis  ticklabel start 0.000000\n";
	ofile<<"@    yaxis  ticklabel stop type auto\n";
	ofile<<"@    yaxis  ticklabel stop 0.000000\n";
	ofile<<"@    yaxis  ticklabel char size 2.000000\n";
	ofile<<"@    yaxis  ticklabel font 0\n";
	ofile<<"@    yaxis  ticklabel color 1\n";
	ofile<<"@    yaxis  tick place both\n";
	ofile<<"@    yaxis  tick spec type none\n";
	ofile<<"@    altxaxis  off\n";
	ofile<<"@    altyaxis  off\n";
	ofile<<"@    legend on\n";
	ofile<<"@    legend loctype view\n";
	ofile<<"@    legend 0.85, 0.8\n";
	ofile<<"@    legend box color 1\n";
	ofile<<"@    legend box pattern 1\n";
	ofile<<"@    legend box linewidth 1.0\n";
	ofile<<"@    legend box linestyle 1\n";
	ofile<<"@    legend box fill color 0\n";
	ofile<<"@    legend box fill pattern 1\n";
	ofile<<"@    legend font 0\n";
	ofile<<"@    legend char size 1.000000\n";
	ofile<<"@    legend color 1\n";
	ofile<<"@    legend length 8\n";
	ofile<<"@    legend vgap 1\n";
	ofile<<"@    legend hgap 1\n";
	ofile<<"@    legend invert false\n";
	ofile<<"@    frame type 0\n";
	ofile<<"@    frame linestyle 1\n";
	ofile<<"@    frame linewidth 1.0\n";
	ofile<<"@    frame color 1\n";
	ofile<<"@    frame pattern 1\n";
	ofile<<"@    frame background color 0\n";
	ofile<<"@    frame background pattern 0\n";
	for(size_t i=0; i<NumSet; i++)
	{
		ofile<<"@    s"<<i<<" hidden false\n";
		ofile<<"@    s"<<i<<" type xy\n";
		ofile<<"@    s"<<i<<" symbol 0\n";
		ofile<<"@    s"<<i<<" symbol size 1.000000\n";
		ofile<<"@    s"<<i<<" symbol color 1\n";
		ofile<<"@    s"<<i<<" symbol pattern 1\n";
		ofile<<"@    s"<<i<<" symbol fill color 1\n";
		ofile<<"@    s"<<i<<" symbol fill pattern 0\n";
		ofile<<"@    s"<<i<<" symbol linewidth 1.0\n";
		ofile<<"@    s"<<i<<" symbol linestyle 1\n";
		ofile<<"@    s"<<i<<" symbol char 65\n";
		ofile<<"@    s"<<i<<" symbol char font 0\n";
		ofile<<"@    s"<<i<<" symbol skip 0\n";
		ofile<<"@    s"<<i<<" line type 1\n";
		ofile<<"@    s"<<i<<" line linestyle "<<(i%NLineStyle)+1<<"\n";
		ofile<<"@    s"<<i<<" line linewidth 3.0\n";
		ofile<<"@    s"<<i<<" line color "<<(i%NColor)+1<<"\n";
		ofile<<"@    s"<<i<<" line pattern 1\n";
		ofile<<"@    s"<<i<<" baseline type 0\n";
		ofile<<"@    s"<<i<<" baseline off\n";
		ofile<<"@    s"<<i<<" dropline off\n";
		ofile<<"@    s"<<i<<" fill type 0\n";
		ofile<<"@    s"<<i<<" fill rule 0\n";
		ofile<<"@    s"<<i<<" fill color 1\n";
		ofile<<"@    s"<<i<<" fill pattern 1\n";
		ofile<<"@    s"<<i<<" avalue off\n";
		ofile<<"@    s"<<i<<" avalue type 2\n";
		ofile<<"@    s"<<i<<" avalue char size 1.000000\n";
		ofile<<"@    s"<<i<<" avalue font 0\n";
		ofile<<"@    s"<<i<<" avalue color 1\n";
		ofile<<"@    s"<<i<<" avalue rot 0\n";
		ofile<<"@    s"<<i<<" avalue format general\n";
		ofile<<"@    s"<<i<<" avalue prec 3\n";
		ofile<<"@    s"<<i<<" avalue prepend \"\"\n";
		ofile<<"@    s"<<i<<" avalue append \"\"\n";
		ofile<<"@    s"<<i<<" avalue offset 0.000000 , 0.000000\n";
		ofile<<"@    s"<<i<<" errorbar on\n";
		ofile<<"@    s"<<i<<" errorbar place both\n";
		ofile<<"@    s"<<i<<" errorbar color 1\n";
		ofile<<"@    s"<<i<<" errorbar pattern 1\n";
		ofile<<"@    s"<<i<<" errorbar size 1.000000\n";
		ofile<<"@    s"<<i<<" errorbar linewidth 1.0\n";
		ofile<<"@    s"<<i<<" errorbar linestyle 1\n";
		ofile<<"@    s"<<i<<" errorbar riser linewidth 1.0\n";
		ofile<<"@    s"<<i<<" errorbar riser linestyle 1\n";
		ofile<<"@    s"<<i<<" errorbar riser clip off\n";
		ofile<<"@    s"<<i<<" errorbar riser clip length 0.100000\n";
		ofile<<"@    s"<<i<<" comment \"\"\n";
		if(i<legends.size())
			ofile<<"@    s"<<i<<" legend  \""<<legends[i]<<"\"\n";
		else
			ofile<<"@    s"<<i<<" legend  \"\"\n";
	}
	for(size_t i=0; i<NumSet; i++)
	{
		const std::vector<GeometryVector> & result = presult[i];
		ofile<<"@target G0.S"<<i<<"\n";
		ofile<<"@type xy\n";
		for(auto iter=result.begin(); iter!=result.end(); iter++)
			ofile<<iter->x[0]<<' '<<iter->x[1]<<'\n';
		ofile<<'&';
	}
}
void PlotFunction_Grace(const std::vector<GeometryVector> * presult, size_t NumSet, const std::string & OutFilePrefix, const std::string & xLabel, const std::string & yLabel, const std::vector<std::string> & legends, const std::string & Title)
{
	const std::vector<GeometryVector> & result = presult[0];
	const size_t NumData=result.size();
	if(NumData==0)
	{
		std::cerr<<"Error in PlotFunction_Grace: No Data ! Exiting function \n";
		return;
	}
	//double MinX = result[0].x[0] - result[0].x[2], MaxX = result[0].x[0] + result[0].x[2];
	//double MinY = result[0].x[1] - result[0].x[3], MaxY = result[0].x[1] + result[0].x[3];
	double MinX = result[0].x[0], MaxX = result[0].x[0];
	double MinY = result[0].x[1], MaxY = result[0].x[1];
	for (size_t j = 0; j<NumSet; j++)
	{
		const std::vector<GeometryVector> & result = presult[j];
		const size_t NumData=result.size();
		for(size_t i=0; i<NumData; i++)
		{
			if(MinX>result[i].x[0])
				MinX=result[i].x[0];
			if(MaxX<result[i].x[0])
				MaxX=result[i].x[0];
			if(MinY>result[i].x[1])
				MinY=result[i].x[1];
			if(MaxY<result[i].x[1])
				MaxY=result[i].x[1];
		}
	}
	double TickX=std::pow(10.0, std::floor(std::log10(MaxX-MinX)-0.1761));
	if( (MaxX-MinX)/TickX<3 )
		TickX*=0.5;
	else if( (MaxX-MinX)/TickX>6 )
		TickX*=2;
 
	double TickY=std::pow(10.0, std::floor(std::log10(MaxY-MinY)-0.1761));
	if( (MaxY-MinY)/TickY<3 )
		TickY*=0.5;
	else if( (MaxY-MinY)/TickY>6 )
		TickY*=2;

	PlotFunction_Grace(presult, NumSet, OutFilePrefix, xLabel, yLabel, legends, Title, MinX, MaxX, TickX, MinY, MaxY, TickY);
}
void PlotFunction_Grace(const std::vector<GeometryVector> & result, const std::string & OutFilePrefix, const std::string & xLabel, const std::string & yLabel, const std::string & Title)
{
	PlotFunction_Grace(&result, 1, OutFilePrefix, xLabel, yLabel, std::vector<std::string>(), Title);
}

void ReadGraceData(std::vector<std::vector<GeometryVector> > & result, std::istream & ifile)
{
	if (!ifile.good())
	{
		std::cout << "Error in ReadGraceData : input file is not valid.\n";
		return;
	}
	result.clear();
	result.push_back(std::vector<GeometryVector>());
	ifile.ignore(10000, '\n');
	std::string line;
	while (!ifile.eof())
	{
		char c = ifile.peek();
		if (c == '@')
			ifile.ignore(10000, '\n');
		else if (c == '#')
			ifile.ignore(10000, '\n');
		else if (c == '&')
		{
			ifile.ignore(10000, '\n');
			result.push_back(std::vector<GeometryVector>());
		}
		else
		{
			std::getline(ifile, line);
			std::stringstream ss(line);
			GeometryVector vec;
			for (int i = 0; i<4 && ss >> vec.x[i]; i++)
				vec.SetDimension(i + 1);
			result.back().push_back(vec);
		}
	}
	result.pop_back();
}
void ReadGraceData(std::vector<std::vector<GeometryVector> > & result, const std::string & InFilePrefix)
{
	std::string name = InFilePrefix + std::string(".agr");
	std::fstream ifile(name.c_str(), std::fstream::in);
	ReadGraceData(result, ifile);
}


/* ---------------------------------
 *	Implementations of g2Computation
 * --------------------------------- */
void g2Computation::Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
{
	omp_set_num_threads(this->num_threads);
	result.clear();
	if (this->pHGen == nullptr)
		::IsotropicTwoPairCorrelation(GetConfigsFunction, NumConfig, g2rmax, result, 5000000, resolution);
	else
		::IsotropicTwoPairCorrelation(GetConfigsFunction, NumConfig, g2rmax, result, *this->pHGen);
}

void g2Computation::Write(const std::string OutputPrefix)
{
	std::vector<std::string> fields;
	fields.emplace_back("#r\t#g_2\t#err. r\t#err. g2");
	logfile<<"g_2:\n";
	WriteFunction(result, (OutputPrefix+std::string("_gofr")).c_str(),fields);
}

void g2Computation::Plot(const std::string OutputPrefix, const std::string & Title)
{
	PlotFunction_Grace(result, OutputPrefix+std::string("_gofr"), "r", "g\\s2\\N(r)", Title);
}

void g2Computation::ProcessAdditionalOption(const std::string & option, std::istream & input, std::ostream & output)
{
	if (option == "ResolutionPreference")
		//default=1, set>1 to get better x resolution, <1 to get better y resolution
		input >> resolution;
	if (option == "ManualBins")
	{
		output << "Input min, increment, and max of bins:";
		double min, inc, max;
		input >> min >> inc >> max;

		if (this->pHGen != nullptr)
			delete this->pHGen;
		this->pHGen = new HistogramGenerator;
		for (double x = min; x < max; x += inc)
			this->pHGen->bins.push_back(HistogramGenerator::bin(0, x));
	}
	else
		output << "Unrecognized command!\n";
}


/* ---------------------------------
 *	Implementations of Directionalg2Computation
 * --------------------------------- */
void Directionalg2Computation::Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
{
	omp_set_num_threads(this->num_threads);
	results.clear();
	TwoPairCorrelation_2DAnisotropic(GetConfigsFunction, NumConfig, g2rmax, results, NumThetaBins);
}

void Directionalg2Computation::Write(const std::string OutputPrefix)
{
	std::fstream xout( (OutputPrefix+std::string("_x.txt")).c_str(), std::fstream::out);
	std::fstream yout( (OutputPrefix+std::string("_y.txt")).c_str(), std::fstream::out);
	std::fstream g2out( (OutputPrefix+std::string("_g2.txt")).c_str(), std::fstream::out);

	for(auto iter=results.begin(); iter!=results.end(); iter++)
	{
		for(auto iter2=iter->begin(); iter2!=iter->end(); iter2++)
		{
			double x=iter2->x[0]*std::cos(iter2->x[1]);
			double y=iter2->x[0]*std::sin(iter2->x[1]);
			xout<<x<<" \t";
			yout<<y<<" \t";
			g2out<<iter2->x[2]<<" \t";
		}
		xout<<'\n';
		yout<<'\n';
		g2out<<'\n';
	}
}


/* ---------------------------------
 *	Implementations of Directionalg2Computation
 * --------------------------------- */
void SkComputation::Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
{
	omp_set_num_threads(this->num_threads);
	result.clear();
	::IsotropicStructureFactor(GetConfigsFunction, NumConfig, CircularKMax, LinearKMax, result, KPrecision, SampleProbability, average_option);
}

void SkComputation::Write(const std::string OutputPrefix)
{
	std::vector<std::string> fields;
	fields.emplace_back("#k\t#S(k)\t#err. k\t#err. S(k)");	
//	std::cout<<"S(k):\n";
//	WriteFunction(result, logfile);
	WriteFunction(result, (OutputPrefix+std::string("_Sofk")).c_str(), fields);
}

void SkComputation::Plot(const std::string OutputPrefix, const std::string & Title)
{
	PlotFunction_Grace(result, OutputPrefix+std::string("_Sofk"), "k", "S(k)", Title);
}
void SkComputation::ProcessAdditionalOption(const std::string & option, std::istream & input, std::ostream & output)
{
	if (option == "SampleProbability")
		//default=1, set>1 to get better x resolution, <1 to get better y resolution
		input >> SampleProbability;
	else if (option == "AverageOverCounts")
		average_option = 0;
	else if (option == "AverageOverSurface")
		average_option = 1;
	else if (option == "BraggPeaks")
		average_option = 2;
	else
		output << "Unrecognized command!\n";
}

void MinNearestNeighborDistrubution(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfigs, std::vector<GeometryVector> & Result, double ResolutionPreference, std::vector<double> & aux)
{
	std::vector<double> distances(NumConfigs, 0);
	std::cout << "Computing the distribution of min. nearest-neighbor distances\n";

	#pragma omp parallel for 
	for (size_t i =0; i<NumConfigs; i++){
		Configuration c = GetConfigsFunction(i);
		size_t N = c.NumParticle();
		double typical_length = pow(c.PeriodicVolume()/(double)N, 1.0/c.GetDimension());
		double Rmin = pow(c.PeriodicVolume(), 1.0/c.GetDimension());
		c.SetCellSize(typical_length);

		for (size_t j = 0; j < N; j++) {
			double temp = c.NearestParticleDistance(j);
			Rmin = (temp < Rmin) ? temp : Rmin;
		}
		distances.at(i) = Rmin;
	}
	aux = std::vector<double> (distances);

	HistogramGenerator HGen;
	HGen.GenerateBins(distances, 1.0, ResolutionPreference);
	Result.clear();
	size_t TotalCount=0;
	for(auto iter=HGen.bins.begin(); iter!=HGen.bins.end(); iter++)
		TotalCount+=iter->Count;

	bool IgnoreBin = true;
	for(auto iter=HGen.bins.begin(); iter!=HGen.bins.end(); iter++)
	{
		GeometryVector temp(4);
		if(iter!=HGen.bins.end()-1)
			temp.x[0]=((iter[0].Start)+(iter[1].Start))/2.0;//r 
		else
			continue;

		if(iter==HGen.bins.begin())
		{
			if(iter->Start==0.0 && (iter[2].Start-iter[1].Start)>iter[1].Start && iter->Count==0)
				continue;//there shouldn't be a bin at here
		}
		temp.x[2]=(temp.x[0]-iter[0].Start);//\delta r

		temp.x[1]=static_cast<double>(iter->Count)/TotalCount/(2*temp.x[2]);//p(r)

		if(iter->Count!=0)
			temp.x[3]=temp.x[1]/std::sqrt(static_cast<double>(iter->Count));//\delta p(r)
		else
			temp.x[3]=0.0;
		if (temp.x[0]>=0.0){
			IgnoreBin &= (temp.x[1] == 0.0);	/* Once the second column is non-zero, IgnoreBin becomes false.*/
			if (! IgnoreBin ){
				Result.push_back(temp);
			}
		}
	}
	if(Verbosity>2)
		std::cout<<"done!\n";	
}

void NearestNeighbors::Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
{
	if (this-> logscale_bin){
		//TODO: Implement log-scaled bins
	}
	else{
		// Nearest-neighbor distribution
		::NearestNeighborDistrubution(GetConfigsFunction, NumConfig, distribution, SampleDistanceSize, resolution);

		// min nearest-neighbor distribution
		MinNearestNeighborDistrubution(GetConfigsFunction, NumConfig, min_distribution, resolution, minPairs);
	}
}

void NearestNeighbors::Write(const std::string OutputPrefix)
{
	// nearest-neighbor distribution
	{
		std::vector<std::string> fields;
		fields.emplace_back("#r\t#Hp(r)\t#err. bin \t#err. Hp(r)");	
		std::cout<<"Hp(r):\n";
		WriteFunction(distribution, (OutputPrefix+std::string("_Hp")).c_str(), fields);
	}

	// distribution of minimal nearest-neighbor distances
	{
		std::vector<std::string> fields;
		fields.emplace_back("#r\t#prob. density\t#err. bin \t#err. prob.(r)");	
		std::cout<<"Distribution of min. nearest-neighbor:\n";
		WriteFunction(min_distribution, (OutputPrefix+std::string("_minNNdist")).c_str(), fields);
	}

	// print all min pair distances 
	if (this->Output_AllMinPairDistances)
	{
		std::cout<<"Print all min. pair distances:\n";

		std::string name = OutputPrefix + std::string("_minPairs") + std::string(".txt");
		std::fstream file(name.c_str(), std::fstream::out);

		file << "#List of all min. pair distances\n";
		file << "#" << minPairs.size() << " configurations \n";
		char text[300]={};
		for (int i=0; i<minPairs.size(); i++){
			sprintf(text, "%1.10e", minPairs[i]);
			file << text <<"\n";
		}
	}
}

void NearestNeighbors::Plot(const std::string OutputPrefix, const std::string &Title)
{
	// nearest-neighbor distribution
	{
		std::vector<std::string> fields;
		fields.emplace_back("#r\t#Hp(r)\t#err. bin \t#err. Hp(r)");	
		std::cout<<"Hp(r):\n";
		PlotFunction_Grace(distribution, OutputPrefix+std::string("_Hp"), "r", "Hp(r)", Title);
	}

	// distribution of minimal nearest-neighbor distances
	{
		std::vector<std::string> fields;
		fields.emplace_back("#r\t#prob. density\t#err. bin \t#err. prob.(r)");	
		std::cout<<"Distribution of min. nearest-neighbor:\n";
		PlotFunction_Grace(min_distribution, OutputPrefix+std::string("_minNN"), "r", "Dist. min. nearest-neighbor", Title);
	}
}

void NearestNeighbors::ProcessAdditionalOption(const std::string &option, std::istream &input, std::ostream &output)
{
	if (option == "ResolutionPreference")
		//default=1, set>1 to get better x resolution, <1 to get better y resolution
		input >> resolution;
	if (option == "LogScale")
		// Bin sizes are determined by a log scale of r when r is small.
		// An option compatible with "ResolutionPreference".
		input >> logscale_bin;

	if (option == "PrintAll"){
		this->Output_AllMinPairDistances = true;
		output << "Print all min. pair distances\n";
	}
	else
		output << "Unrecognized command!\n";
}

void LocalNumberVariance::Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
{
	omp_set_num_threads(this->num_threads);
	if (this->use_prt_centers){
		/* Window centers = particle centers */
		this->result.clear();

		std::cout<< "\nComputing Number Variance (Use particle centers): ";
		progress_display pd(NumConfig);
		for (int i = 0; i < NumConfig; i++){
			Configuration c = GetConfigsFunction(i);
			std::vector<GeometryVector> centers;
			centers.reserve(c.NumParticle());
			for (int j = 0; j < c.NumParticle(); j++){
				GeometryVector v = c.GetRelativeCoordinates(j);
				centers.push_back(v);
				//std::cout << j<<", "<< v.Dimension << "\t" << v;
			}
			// std::cout << "start\n";
			std::vector<GeometryVector> result_temp;
			/* Compute variance of an individual configuration. */
			MC_NV_single(c, result_temp, Rmax, dR, centers);
			pd++;

			if (i == 0){
				this->result = std::vector<GeometryVector> (result_temp);
				for (int j = 0; j < this->result.size(); j++){
					this->result[j].x[3] = this->result[j].x[1];
					this->result[j].x[1] = 0.0;
				}
			}
			else{
				for (int j = 0; j < this->result.size(); j++){
					double val = result_temp[j].x[1] - this->result[j].x[3];
					this->result[j].x[1] += val;
					this->result[j].x[2] += val*val;
				}
			}
		}
		/* Summarize data */
		for(int i = 0; i < this->result.size(); i++){
			this->result[i].x[1] /= (double)NumConfig;
			/*SE*/
			if(NumConfig > 1){
				this->result[i].x[2] = std::sqrt(abs(this->result[i].x[2]/NumConfig - this->result[i].x[1]*this->result[i].x[1])/(NumConfig-1));	
			}
			else{
				this->result[i].x[2] = 0.0;
			}
			this->result[i].x[1] += this->result[i].x[3];
			this->result[i].x[3] = 0.0;
		}
		std::cout << "done!\n";
	}
	else{
		MC_NV_Ensemble(GetConfigsFunction, NumConfig, 
		this->result, this-> Rmax, this-> dR, this->num_samp_centers);
	}
}

void LocalNumberVariance::Write(const std::string OutputPrefix)
{
	std::vector<std::string> fields;
	std::string outputname(OutputPrefix);
	fields.emplace_back("y = Local Number Variance at window radius R\n");	
	if (this->use_prt_centers){
		fields.emplace_back("Use particle centers as window centers\n");			
		outputname += std::string("_nv_self");
	}
	else{
		fields.emplace_back("Use random window centers: "+std::to_string(this->num_samp_centers) + "\n");
		outputname += std::string("_nv");
	}
	fields.emplace_back("R\ty(R)\tErr. y");
	//std::cout<<"Done!\n";
	WriteFunction(this->result, outputname.c_str(), fields);
}

void LocalNumberVariance::Plot(const std::string OutputPrefix, const std::string &Title)
{
	PlotFunction_Grace(this->result, OutputPrefix+std::string("_nv"), "R", "Local Number Variance", Title);
}

void LocalNumberVariance::ProcessAdditionalOption(const std::string &option, std::istream &input, std::ostream &output)
{
	if (option == "UseParticleCenters"){
		this->use_prt_centers = true;
		output << "Use particle centers as sampling centers\n";
		output << "Sampling centers are taken to be less than or equal to particle number N\n";
	}
	//default=1, set>1 to get better x resolution, <1 to get better y resolution
}


/* ---------------------------------
 *	Implementations of CoordinationNumberComputation
 * --------------------------------- */

void CoordinationNumberComputation::Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
{
	omp_set_num_threads(this->num_threads);
	ContactNumbers(GetConfigsFunction, NumConfig, this->rmin, this->rmax, this->result);
}

void CoordinationNumberComputation::Write(const std::string OutputPrefix)
{
	std::vector<std::string> fields;
	fields.emplace_back("#Local Z\t# P(Z) \t#err. P(Z) ");
	WriteFunction(result, (OutputPrefix+std::string("_Z")).c_str(),fields);
}

void CoordinationNumberComputation::Plot(const std::string OutputPrefix, const std::string & Title)
{
	PlotFunction_Grace(result, OutputPrefix+std::string("_Z"), "Local Z", "P(Z)", Title);
}

void CoordinationNumberComputation::ProcessAdditionalOption(const std::string & option, std::istream & input, std::ostream & output)
{
	output << "Unrecognized command!\n";
}

void CumulativeCoordinationNumberComputation::Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
{
	CumulativeCoordinationNumber( GetConfigsFunction, NumConfig, rmin, rmax, dr, result);
}

void CumulativeCoordinationNumberComputation::Write(const std::string OutputPrefix)
{
	std::vector<std::string> fields;
	fields.emplace_back("#Z(r) = cumulative coordination number up to r");	
	fields.emplace_back("#r\t#Z(r)\t#err. Z ");	
	std::cout<<"Z(r):\n";
	WriteFunction(result, (OutputPrefix+std::string("_Zofr")).c_str(), fields);
}

void CumulativeCoordinationNumberComputation::Plot(const std::string OutputPrefix, const std::string &Title)
{
	PlotFunction_Grace(result, OutputPrefix+std::string("_Zofr"), "r", "Cumulative Coordination number", Title);
}

void CumulativeCoordinationNumberComputation::ProcessAdditionalOption(const std::string &option, std::istream &input, std::ostream &output)
{
	output << "Unrecognized command!\n";
}
